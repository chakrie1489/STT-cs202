# Test cases automatically generated by Pynguin (https://www.pynguin.eu).
# Please check them before you use them.
import pytest
import algorithms.strings.reverse_words as module_0


@pytest.mark.xfail(strict=True)
def test_case_0():
    none_type_0 = None
    module_0.reverse(none_type_0, none_type_0, none_type_0)


@pytest.mark.xfail(strict=True)
def test_case_1():
    bytes_0 = b"\xc8\xedqa\xfd\x0bi\x1b\x89\x1b\xbd\x00"
    module_0.reverse_words(bytes_0)


def test_case_2():
    bool_0 = True
    var_0 = module_0.reverse(bool_0, bool_0, bool_0)


@pytest.mark.xfail(strict=True)
def test_case_3():
    none_type_0 = None
    module_0.reverse_words(none_type_0)


def test_case_4():
    str_0 = "\nFor positive integer n and given integer a that satisfies gcd(a, n) = 1,\nthe order of a modulo n is the smallest positive integer k that satisfies\npow (a, k) % n = 1. In other words, (a^k) ≡ 1 (mod n).\nOrder of a certain number may or may not be exist. If not, return -1.\n\nTotal time complexity O(nlog(n)):\nO(n) for iteration loop, \nO(log(n)) for built-in power function\n"
    var_0 = module_0.reverse_words(str_0)
    assert (
        var_0
        == "function power built-in for O(log(n)) loop, iteration for O(n) O(nlog(n)): complexity time Total -1. return not, If exist. be not may or may number certain a of Order n). (mod 1 ≡ (a^k) words, other In 1. = n % k) (a, pow satisfies that k integer positive smallest the is n modulo a of order the 1, = n) gcd(a, satisfies that a integer given and n integer positive For"
    )
