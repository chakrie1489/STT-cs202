# Test cases automatically generated by Pynguin (https://www.pynguin.eu).
# Please check them before you use them.
import pytest
import algorithms.tree.construct_tree_postorder_preorder as module_0


def test_case_0():
    bytes_0 = b"\xf6\xf7\xa4s"
    tree_node_0 = module_0.TreeNode(bytes_0, bytes_0)
    assert module_0.pre_index == 1322


def test_case_1():
    int_0 = -687
    var_0 = module_0.construct_tree(int_0, int_0, int_0)
    assert module_0.pre_index == 1322


def test_case_2():
    int_0 = 999
    module_0.construct_tree(int_0, int_0, int_0)
    assert module_0.pre_index == 1322


@pytest.mark.xfail(strict=True)
def test_case_3():
    bytes_0 = b"\xbd$\xe62\xb6\x9f\xdd\xa4\xa2\x91\xa4"
    module_0.construct_tree_util(bytes_0, bytes_0, bytes_0, bytes_0, bytes_0)


def test_case_4():
    none_type_0 = None
    var_0 = module_0.print_inorder(none_type_0, none_type_0)
    assert module_0.pre_index == 1322


@pytest.mark.xfail(strict=True)
def test_case_5():
    bytes_0 = b"\xf6\xf7\xa4s"
    module_0.print_inorder(bytes_0, bytes_0)


@pytest.mark.xfail(strict=True)
def test_case_6():
    bytes_0 = b"\xbd$\xe62\xb6\x9f\xdd\xa4\xa2\x91\xa4"
    module_0.construct_tree(bytes_0, bytes_0, bytes_0)


@pytest.mark.xfail(strict=True)
def test_case_7():
    bytes_0 = b"\xf6\xf7\xa4s"
    module_0.print_inorder(bytes_0)


def test_case_8():
    bytes_0 = b"\xbd$\xe62\xb6\x9f\xdd\xa4\xa2\x91\xa4"
    int_0 = 999
    module_0.construct_tree(bytes_0, bytes_0, int_0)
    assert module_0.pre_index == 1322


def test_case_9():
    bytes_0 = b"\x92\xa6\x14\xacz\xb7m\x0f\xf7;"
    int_0 = 999
    bool_0 = False
    int_1 = 384
    list_0 = [bytes_0, int_1, int_0]
    int_2 = 998
    bool_1 = True
    var_0 = module_0.construct_tree_util(bool_0, list_0, int_2, bool_1, int_0)
    assert module_0.pre_index == 1322
    list_1 = [bytes_0]
    int_3 = -3237
    var_1 = module_0.construct_tree(list_1, list_1, int_3)


def test_case_10():
    none_type_0 = None
    tree_node_0 = module_0.TreeNode(none_type_0)
    assert module_0.pre_index == 1322
    str_0 = "\nYou are given two non-empty linked lists representing\ntwo non-negative integers. The digits are stored in reverse order\nand each of their nodes contain a single digit.\nAdd the two numbers and return it as a linked list.\n\nYou may assume the two numbers do not contain any leading zero,\nexcept the number 0 itself.\n\nInput: (2 -> 4 -> 3) + (5 -> 6 -> 4)\nOutput: 7 -> 0 -> 8\n"
    int_0 = 1125
    module_0.construct_tree(str_0, str_0, int_0)


@pytest.mark.xfail(strict=True)
def test_case_11():
    none_type_0 = None
    tree_node_0 = module_0.TreeNode(none_type_0)
    assert module_0.pre_index == 1322
    var_0 = module_0.print_inorder(tree_node_0)
    var_1 = module_0.print_inorder(tree_node_0)
    str_0 = "The edit distance between two words is the minimum number\nof letter insertions, letter deletions, and letter substitutions\nrequired to transform one word into another.\n\nFor example, the edit distance between FOOD and MONEY is at\nmost four:\n\nFOOD -> MOOD -> MOND -> MONED -> MONEY\n\nGiven two words A and B, find the minimum number of operations\nrequired to transform one string into the other.\nIn other words, find the edit distance between A and B.\n\nThought process:\n\nLet edit(i, j) denote the edit distance between\nthe prefixes A[1..i] and B[1..j].\n\nThen, the function satifies the following recurrence:\n\nedit(i, j) = i if j = 0\n             j if i = 0\n             min(edit(i-1, j) + 1,\n                 edit(i, j-1), + 1,\n                 edit(i-1, j-1) + cost) otherwise\n\nThere are two base cases, both of which occur when one string is empty\nand the other is not.\n1. To convert an empty string A into a string B of length n,\nperform n insertions.\n2. To convert a string A of length m into an empty string B,\nperform m deletions.\n\nHere, the cost is 1 if a substitution is required,\nor 0 if both chars in words A and B are the same at\nindexes i and j, respectively.\n\nTo find the edit distance between two words A and B,\nwe need to find edit(length_a, length_b).\n\nTime: O(length_a*length_b)\nSpace: O(length_a*length_b)\n"
    int_0 = 1127
    var_2 = module_0.construct_tree(str_0, str_0, int_0)
    int_1 = 1726
    module_0.construct_tree_util(var_1, var_1, int_1, var_2, tree_node_0)
